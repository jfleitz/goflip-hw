; Z8 Encore! ANSI C Compiler Release 3.64
; -nofastcall -const=ROM -listinc -model=S -optlink -regvar
; -noreduceopt -debug -norevaa -peephole -localcse -optsize
; -alias 
	DEFINE pdriver_TEXT,SPACE=ROM
	FILE	".\lampdriver.c"
.debug "C"
	SEGMENT ROM_DATA
__ldu_map:
	DB	224
	DB	225
	DB	226
	DB	227
	DB	228
	DB	229
	DB	230
	DB	231
	DB	232
	DB	233
	DB	234
	DB	235
	DB	236
	DB	237
	DB	238
	DB	239
	DB	208
	DB	209
	DB	210
	DB	211
	DB	212
	DB	213
	DB	214
	DB	215
	DB	216
	DB	217
	DB	218
	DB	219
	DB	220
	DB	221
	DB	222
	DB	223
	DB	176
	DB	177
	DB	178
	DB	179
	DB	180
	DB	181
	DB	182
	DB	183
	DB	184
	DB	185
	DB	186
	DB	187
	DB	188
	DB	189
	DB	190
	DB	191
	DB	112
	DB	113
	DB	114
	DB	115
	DB	116
	DB	117
	DB	118
	DB	119
	DB	120
	DB	121
	DB	122
	DB	123
	DB	124
	DB	125
	DB	126
	DB	127
.define "_ldu_map"
.alias "__ldu_map"
.class 52
.value __ldu_map
.dim 64
.type 108
.endef
	SEGMENT pdriver_TEXT
;    1	/*!\file gpio.h
;    2	 * \brief Definition file for the Z8 Encore! GPIO Ports.
;    3	 *
;    4	 *  This file contains header information required by GPIO Port
;    5	 *  driver implementations for Z8 Encore! microcontrollers.
;    6	 *
;    7	 *  This source file uses Doxygen-style comments to generate documentation
;    8	 *  automatically.
;    9	 *
;   10	 *  Copyright (C) 1999-2004 by  ZiLOG, Inc.
;   11	 *  All Rights Reserved.
;   12	 */
;   13	
;   14	#pragma once // Include this file only once
;   15	#ifndef _GPIO_H_
;   16	#define _GPIO_H_
;   17	
;   18	#include <defines.h>
;   19	
;   20	
;   21	#ifdef _DEBUG
;   22	#define GPIOPARAMETER_CHECKING									//!< Parameter validation control macro.
;   23	#endif
;   24	
;   25	
;   26	/*! The GPIO ports available for particular target. Port A, B and C are available for all targets */
;   27	#if (defined(EZ8_PORT4) && !defined(_Z8F04)) || defined(EZ8_PORT8)||defined(EZ8_PORT5)
;   28	#define PORTD
;   29	#endif
;   30	
;   31	#if defined(EZ8_PORT8)||defined(EZ8_PORT5)
;   32	#define PORTE
;   33	#endif
;   34	#if defined(EZ8_PORT8)
;   35	#define PORTF
;   36	#define PORTG
;   37	#define PORTH
;   38	#endif
;   39	
;   40	#define GPIOERR_SUCCESS		(CHAR)0			//!< Error code for success returned by GPIO APIs.
;   41	#define GPIOERR_INVALIDPINS	(CHAR)1			//!< Error code for invalid GPIO pin for the target.
;   42	#define GPIOERR_FAILURE		(CHAR)(-1)		//!< Error code for failure returned by GPIO APIs.
;   43	
;   44	
;   45	/*! all the ports bits are set to input mode */
;   46	#define PORTA_ADDRVAL_DEF   0x01
;   47	#define PORTA_CTLVAL_DEF    0xFF
;   48	#define PORTA_OUTVAL_DEF    0x00
;   49	
;   50	#define PORTB_ADDRVAL_DEF   0x01
;   51	#define PORTB_CTLVAL_DEF    0xFF
;   52	#define PORTB_OUTVAL_DEF    0x00
;   53	
;   54	#define PORTC_ADDRVAL_DEF   0x01
;   55	#define PORTC_CTLVAL_DEF    0xFF
;   56	#define PORTC_OUTVAL_DEF    0x00
;   57	
;   58	#ifdef PORTD
;   59	#define PORTD_ADDRVAL_DEF   0x01
;   60	#define PORTD_CTLVAL_DEF    0xFF
;   61	#define PORTD_OUTVAL_DEF    0x00
;   62	#endif
;   63	
;   64	#ifdef PORTE
;   65	#define PORTE_ADDRVAL_DEF   0x01
;   66	#define PORTE_CTLVAL_DEF    0xFF
;   67	#define PORTE_OUTVAL_DEF    0x00
;   68	#endif
;   69	
;   70	#ifdef PORTF
;   71	#define PORTF_ADDRVAL_DEF   0x01
;   72	#define PORTF_CTLVAL_DEF    0xFF
;   73	#define PORTF_OUTVAL_DEF    0x00
;   74	#endif
;   75	
;   76	#ifdef PORTG
;   77	#define PORTG_ADDRVAL_DEF   0x01
;   78	#define PORTG_CTLVAL_DEF    0xFF
;   79	#define PORTG_OUTVAL_DEF    0x00
;   80	#endif
;   81	
;   82	#ifdef PORTH
;   83	#define PORTH_ADDRVAL_DEF   0x01
;   84	#define PORTH_CTLVAL_DEF    0xFF
;   85	#define PORTH_OUTVAL_DEF    0x00
;   86	#endif
;   87	
;   88	
;   89	/*! Control Register access codes used in Address registers */
;   90	#define PORTADDR_NOFUNC			0x00
;   91	#define PORTADDR_DATADIR		0x01
;   92	#define PORTADDR_ALTFUNC		0x02
;   93	#if defined(_Z8FMC16) || defined(__ZSLBUILD)
;   94	#define PORTADDR_ALTFUNC0		0x02
;   95	#endif
;   96	#define PORTADDR_OPENDRAIN		0x03
;   97	#define PORTADDR_HIGHDRIVE		0x04
;   98	#define PORTADDR_STPMDREC		0x05
;   99	#if defined (_Z8F1680)||defined(_Z8F04) || defined(_Z8F04A) || defined(_Z8F04A_8PIN) || defined(_Z8F04_8PIN) || defined(_Z8F08) || defined(_Z8F0823_8PIN) || defined(_Z8F08A) || defined(_Z8FMC16) || defined(__ZSLBUILD)
;  100	#define PORTADDR_PULLUP		0x06
;  101	#endif
;  102	#if defined (_Z8F1680)||defined(_Z8F04) || defined(_Z8F04A) || defined(_Z8F04A_8PIN) || defined(_Z8F04_8PIN) || defined(_Z8F0823_8PIN) || defined(_Z8F08A) || defined(__ZSLBUILD)
;  103	#define PORTADDR_ALTFUNCSET1	0x07
;  104	#define PORTADDR_ALTFUNCSET2	0x08
;  105	#endif
;  106	#if defined(_Z8FMC16) || defined(__ZSLBUILD)
;  107	#define PORTADDR_ALTFUNC1		0x07
;  108	#define PORTADDR_IRQES			0x08
;  109	#define PORTADDR_IRQPS			0x09
;  110	#endif
;  111	
;  112	
;  113	/*! Definitions for Current Drive Levels used in LED Drive Mode */
;  114	#if defined(_Z8F04A) ||defined (_Z8F1680)|| defined(__ZSLBUILD)
;  115	#define DRIVELEVEL_3MA			0
;  116	#define DRIVELEVEL_7MA			1
;  117	#define DRIVELEVEL_13MA			2
;  118	#define DRIVELEVEL_20MA			3
;  119	#endif
;  120	
;  121	/*! Definitions for trigger edges */
;  122	#define EDGE_FALLING			0
;  123	#define EDGE_RISING				1
;  124	
;  125	/*! GPIO pin patterns */
;  126	#define PORTPIN_ZERO		(BYTE)0x01			//!< The bit mask for Port bit 0.
;  127	#define PORTPIN_ONE			(BYTE)0x02			//!< The bit mask for Port bit 1.
;  128	#define PORTPIN_TWO			(BYTE)0x04			//!< The bit mask for Port bit 2.
;  129	#define PORTPIN_THREE		(BYTE)0x08			//!< The bit mask for Port bit 3.
;  130	#define PORTPIN_FOUR		(BYTE)0x10			//!< The bit mask for Port bit 4.
;  131	#define PORTPIN_FIVE 		(BYTE)0x20			//!< The bit mask for Port bit 5.
;  132	#define PORTPIN_SIX			(BYTE)0x40			//!< The bit mask for Port bit 6.
;  133	#define PORTPIN_SEVEN		(BYTE)0x80			//!< The bit mask for Port bit 7.
;  134	#define PORTPIN_FOURPINS_L	(BYTE)0x0F			//!< The bit mask for lower four Port bits.
;  135	#define PORTPIN_FOURPINS_U	(BYTE)0xF0			//!< The bit mask for upper four Port bits.
;  136	#define PORTPIN_PATTERN_AA	(BYTE)0xAA			//!< The bit mask for alternate bits (odd numbered pins).
;  137	#define PORTPIN_PATTERN_55	(BYTE)0x55			//!< The bit mask for alternate bits (even numbered pins).
;  138	#define PORTPIN_ALL			(BYTE)0xFF			//!< The bit mask for all Port bits.
;  139	
;  140	/*! Port mask index used for validating the port pins */
;  141	#define MSKINDEX_PORTB		(BYTE)0
;  142	#define MSKINDEX_PORTC		(BYTE)1
;  143	#define MSKINDEX_PORTD		(BYTE)2
;  144	#define MSKINDEX_PORTE		(BYTE)3
;  145	#define MSKINDEX_PORTF		(BYTE)4
;  146	#define MSKINDEX_PORTG		(BYTE)5
;  147	#define MSKINDEX_PORTH		(BYTE)6
;  148	
;  149	/*!
;  150	 * \brief The settings required to configure the GPIO Port.
;  151	 */
;  152	typedef struct
;  153	{
;  154		BYTE addr ;					//!< The address register.
;  155		BYTE ctl ;					//!< The control register.
;  156		BYTE out ;					//!< The output register (write-only).
;  157		BYTE in ;					//!< The input register (read-only).
;  158	
;  159	} PORT ;
.begrec "NONAME0",4
.define "addr"
.value 0
.class 8
.type 12
.endef
.define "ctl"
.value 1
.class 8
.type 12
.endef
.define "out"
.value 2
.class 8
.type 12
.endef
.define "in"
.value 3
.class 8
.type 12
.endef
.endrec "NONAME0"
;    1	/*************************************************
;    2	 *  Copyright (C) 1999-2012 by  ZiLOG, Inc.
;    3	 *  All Rights Reserved
;    4	 *************************************************
;    5	 *
;    6	 * This header is for internal use only. It is NOT
;    7	 * an ANSI standard header file.						
;    8	 *
;    9	 *************************************************/
;   10	
;   11	#pragma once // Include this file only once
;   12	#ifndef FORMAT_H
;   13	#define FORMAT_H
;   14	
;   15	#include <zconst.h>
;   16	#include <stdarg.h>
;   17	
;   18	/* Note: 24 bits times log(2) is 7.224 decimal digits.
;   19	   We only need 14 if and when we support doubles. */
;   20	#define MAXDIGITS 10
;   21	#define MINEXP -4
;   22	#define DEFAULT_PRECISION 6
;   23	
;   24	
;   25	/*  Sizes allowed for various data */
;   26	/*  For small model, we must restrict the allowed input */
;   27	#if (defined(__MODEL__) && (__MODEL__ == 0)) && !defined(__ACCLAIM__)
;   28	#define FLT_CHARS 20  // Only need FLT_DIG+7, but allow for extra data
;   29	#define PTR_CHARS 11
;   30	#define INT_CHARS 9
;   31	#else
;   32	#define FLT_CHARS 127
;   33	#define PTR_CHARS 127
;   34	#define INT_CHARS 127
;   35	#endif
;   36	
;   37	/*	structures and defines for format routines	                 */
;   38	/*      NOTE: Some fields in this structure, and the bits in flags, are  */
;   39	/*            known to the optimizer,  If you change this, check out the */
;   40	/*            code in optimizer/genprintfs.c                             */
;   41	struct fmt_type {
;   42	  char flags;		/* flags bit mask */
;   43	  char size;		/* size character h,l or L */
;   44	  char space;		/* space character N,F or R */
;   45	  char type;		/* type of argument d,i,o,u,x ... */
;   46	  char field_width;	/* field width */
;   47	  char precision;	/* precision */
;   48	  char print_leading_char;  // Initial +, -, or space for number
;   49	     /* several print helper functions end by clearing the above fields. 
;   50	      * The following need to be preserved across calls to the print
;   51	      * utilities.
;   52	      */
;   53	  far char* dest;       /* Destination for sprintf, NULL for printf */
;   54	  unsigned char print_len;
;   55	};
.begrec "fmt_type",10
.define "flags"
.value 0
.class 8
.type 2
.endef
.define "size"
.value 1
.class 8
.type 2
.endef
.define "space"
.value 2
.class 8
.type 2
.endef
.define "type"
.value 3
.class 8
.type 2
.endef
.define "field_width"
.value 4
.class 8
.type 2
.endef
.define "precision"
.value 5
.class 8
.type 2
.endef
.define "print_leading_char"
.value 6
.class 8
.type 2
.endef
.define "dest"
.value 7
.class 8
.type 162
.endef
.define "print_len"
.value 9
.class 8
.type 12
.endef
.endrec "fmt_type"
;   56	
;   57	/* Some additional data for formatting of floating point values: */
;   58	
;   59	struct flt_fmt_data
;   60	{
;   61	  unsigned char pad_whole;
;   62	  unsigned char pad_pre_fract;
;   63	  unsigned char pad_post_fract;
;   64	  char * pad_at;
;   65	};
.begrec "flt_fmt_data",4
.define "pad_whole"
.value 0
.class 8
.type 12
.endef
.define "pad_pre_fract"
.value 1
.class 8
.type 12
.endef
.define "pad_post_fract"
.value 2
.class 8
.type 12
.endef
.define "pad_at"
.value 3
.class 8
.type 130
.endef
.endrec "flt_fmt_data"
;   66	
;   67	/* Data passed between top level driver and scanning routines, not needed
;   68	 * when printf's are generated inline */
;   69	struct fmt_control_data
;   70	{
;   71	  char status;		/* status, OK, ERR, or PASS_THRU */
;   72	  char chr;		/* pass thru character */
;   73	};
.begrec "fmt_control_data",2
.define "status"
.value 0
.class 8
.type 2
.endef
.define "chr"
.value 1
.class 8
.type 2
.endef
.endrec "fmt_control_data"
;   74	
;   75	
;   76	struct _set_type{ char * begin; char *end; };
.begrec "_set_type",2
.define "begin"
.value 0
.class 8
.type 130
.endef
.define "end"
.value 1
.class 8
.type 130
.endef
.endrec "_set_type"
;   77	struct near_set_type{ char near * begin; char near *end; };
.begrec "near_set_type",2
.define "begin"
.value 0
.class 8
.type 130
.endef
.define "end"
.value 1
.class 8
.type 130
.endef
.endrec "near_set_type"
;   78	struct far_set_type{ char far * begin; char far *end; };
.begrec "far_set_type",4
.define "begin"
.value 0
.class 8
.type 162
.endef
.define "end"
.value 2
.class 8
.type 162
.endef
.endrec "far_set_type"
;   79	struct rom_set_type{ char rom * begin; char rom *end; };
.begrec "rom_set_type",4
.define "begin"
.value 0
.class 8
.type 194
.endef
.define "end"
.value 2
.class 8
.type 194
.endef
.endrec "rom_set_type"
;   80	
;   81	/* info flags */
;   82	#define FLT_INFO_SIGN	(1<<0)
;   83	#define FLT_INFO_INF	(1<<1)
;   84	#define FLT_INFO_NAN	(1<<2)
;   85	
;   86	
;   87	struct flt_info {
;   88	  unsigned char flags;			/* 1=sign, 2=inf, 4=nan        */
;   89	  char exp;				/* (signed) exponent (base 10) */
;   90	  unsigned char digits[MAXDIGITS];	/* max significant digits      */
;   91	};
.begrec "flt_info",12
.define "flags"
.value 0
.class 8
.type 12
.endef
.define "exp"
.value 1
.class 8
.type 2
.endef
.define "digits"
.value 2
.class 8
.dim 10
.type 108
.endef
.endrec "flt_info"
	SEGMENT NEAR_BSS
__dataIn:
	DS	4*1
.define "_dataIn"
.alias "__dataIn"
.class 147
.value __dataIn
.type 5
.endef
__lightControl:
	DS	64
.define "_lightControl"
.alias "__lightControl"
.class 147
.value __lightControl
.dim 64
.type 108
.endef
__slowBlink:
	DS	1
.define "_slowBlink"
.alias "__slowBlink"
.class 147
.value __slowBlink
.type 12
.endef
__fastBlink:
	DS	1
.define "_fastBlink"
.alias "__fastBlink"
.class 147
.value __fastBlink
.type 12
.endef
	SEGMENT NEAR_DATA
__strobe:
	DB	0
.define "_strobe"
.alias "__strobe"
.class 133
.value __strobe
.type 12
.endef
__lmp:
	DB	0
.define "_lmp"
.alias "__lmp"
.class 133
.value __lmp
.type 12
.endef
__diagMode:
	DB	0
.define "_diagMode"
.alias "__diagMode"
.class 133
.value __diagMode
.type 12
.endef
	SEGMENT NEAR_BSS
__timerControl:
	DS	2*1
.define "_timerControl"
.alias "__timerControl"
.class 147
.value __timerControl
.type 3
.endef
	SEGMENT NEAR_DATA
__lampCounter:
	DW	0
.define "_lampCounter"
.alias "__lampCounter"
.class 133
.value __lampCounter
.type 3
.endef
	SEGMENT ROM_DATA
_BLINKON:
	DB	63
.define "BLINKON"
.alias "_BLINKON"
.class 52
.value _BLINKON
.type 12
.endef
_BLINKOFF:
	DB	0
.define "BLINKOFF"
.alias "_BLINKOFF"
.class 52
.value _BLINKOFF
.type 12
.endef
	SEGMENT NEAR_BSS
_ledIsOn:
	DS	2*1
.define "ledIsOn"
.alias "_ledIsOn"
.class 147
.value _ledIsOn
.type 3
.endef
_lastDataReceived:
	DS	1
.define "lastDataReceived"
.alias "_lastDataReceived"
.class 147
.value _lastDataReceived
.type 12
.endef
	SEGMENT ROM_DATA


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_LampLoop                           IMPORT  -----   function
;_Initialize                         IMPORT  -----   function
;_lastDataReceived                   STATIC      1   variable


; Aggregate Stack Size: 0 (words)


	.FRAME _n_main,?_n_main,RDATA
	.FCALL _n_Initialize
	.FCALL _n_LampLoop
;    1	/*
;    2	********************************************************
;    3	* File : lampDriver.c
;    4	* Based on scl_interrupt.c (from AN0139-SC02)
;    5	* Description : Drives a lamp Driver board using i2c
;    6	*  PC0 and PC1 have to be used for the i2c pins, as these have interrupt triggering
;    7	*
;    8	*
;    9	* Drives 64 lamps
;   10	* Data Byte command: 0bAAAA AAcc
;   11	* Bits A (data bit 2-7) = Lamp Address
;   12	* Bits C:
;   13	*		00 = off
;   14	*		01 = on
;   15	*		10 = slow blink
;   16	*		11 = fast blink
;   17	*
;   18	*
;   19	*
;   20	*	Green = Lamp Adress 1 (8) = pin 9 = pa0
;   21	*	Blue = Lamp Address 2 (9) = pin 7 = pa1
;   22	*	Purple = Address 3 (4) = pin 5 = pa2
;   23	*	Gray = Address 4 (3) = pin 3 = pa3
;   24	*
;   25	*	Brown = Lamp En 1 (1)= pin 18 = pa4
;   26	*	Red =  Lamp En 2 (2) = pin 16 = pa5
;   27	*	Orange = Lamp En 3(5) = pin 14 = pa6
;   28	*	Yellow = Lamp En 4 (7) = pin 12 = pa7
;   29	*
;   30	*
;   31	*	Lamp En must be 0 for selecting.
;   32	*	Address is active high
;   33	*
;   34	*
;   35	**************************************************************
;   36	*/
;   37	
;   38	#include <ez8.h>
;   39	#include <stdio.h>
;   40	
;   41	#include "lampDriver.h"
;   42	#include "timer.h"
;   43	#include "sysclk.h"
;   44	#include "i2cbase.h"
;   45	
;   46	unsigned char const _ldu_map[64]= {0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,
;   47	0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,
;   48	0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,
;   49	0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
;   50	0x7A,0x7B,0x7C,0x7D,0x7E,0x7F};
;   51	
;   52	
;   53	long _dataIn;
;   54	
;   55	/*Lamp Specific Variables*/
;   56	unsigned char _lightControl[64];
;   57	unsigned char _slowBlink;
;   58	unsigned char _fastBlink;
;   59	unsigned char _strobe = 0;
;   60	unsigned char _lmp = 0;
;   61	unsigned char _diagMode = 0;
;   62	
;   63	int  _timerControl;
;   64	
;   65	int _lampCounter = 0;
;   66	
;   67	unsigned char const BLINKON = 0x3f;
;   68	unsigned char const BLINKOFF =0x00;
;   69	
;   70	void Initialize(void);
;   71	void LampLoop(void);
;   72	void SetLampAll(int value);
;   73	void SetLamp(int , unsigned char );
;   74	void DiagLEDControl(unsigned char);
;   75	static void pause( void );
;   76	int ledIsOn;
;   77	
;   78	
;   79	unsigned char lastDataReceived;
	SEGMENT pdriver_TEXT
;   80	
;   81	
;   82	/* *******************************************************************************
;   83	The main routine ,sets the Port pins PC0 and PC1 to work as either input or output
;   84	with open drain.The I2C bus status is set to free(No Transaction on the I2C bus).
;   85	Sets the interrupt PC0 and PC1 to highist priority.Enables the interrupt.
;   86	/*********************************************************************************/ 
;   87	void main()
;   88	{
_main:
.define "_main"
.value _main
.class 2
.type 65
.endef
.begfunc "main",88,"_main"
;   89	  lastDataReceived = 0x00;
.line 89
	CLR	_lastDataReceived
;   90	  Initialize();
.line 90
	CALL	_Initialize
;   91	  LampLoop();
.line 91
	CALL	_LampLoop
;   92	 }
.line 92
	RET	
.endfunc "main",92,"_main"
	SEGMENT ROM_DATA


;**************************** _Initialize ***************************
;Name                         Addr/Register   Size   Type
;_EI                                 IMPORT  -----   function
;_SetLampAll                         IMPORT  -----   function
;__fastBlink                         STATIC      1   variable
;__slowBlink                         STATIC      1   variable
;_InitializeI2C                      IMPORT  -----   function
;_DI                                 IMPORT  -----   function


; Aggregate Stack Size: 0 (words)


	.FRAME _n_Initialize,?_n_Initialize,RDATA
	.FCALL _n_InitializeI2C
	.FCALL _n_SetLampAll
	SEGMENT pdriver_TEXT
;   93	
;   94	
;   95	 
;   96	 void Initialize(void){
_Initialize:
.define "_Initialize"
.value _Initialize
.class 2
.type 65
.endef
.begfunc "Initialize",96,"_Initialize"
;   97		DI();				// Globally disable all interrupts    
.line 97
	DI
;   98	
;   99		InitializeI2C();
.line 99
	CALL	_InitializeI2C
;  100	
;  101		//PB0-3 are open drain for LED control
;  102		PBADDR = 0x01; // Direction
.line 102
	LDX	4052,#1
;  103		PBCTL = 0xE8; //1110 - 1000 all putputs are zeros
.line 103
	LDX	4053,#232
;  104		PBADDR = 0x03; //output control
.line 104
	LDX	4052,#3
;  105		PBCTL = 0x07;     //0000-0111 (open drain on PB0-PB3)
.line 105
	LDX	4053,#7
;  106		PBADDR = 0x00;
.line 106
	LDX	4052,#-0
;  107	
;  108		//PA0-7 should be TTL output
;  109		PAADDR = 0x01; //Data Direction
.line 109
	LDX	4048,#1
;  110		PACTL = 0x00; //0000 - 0000 all putputs are zeros
.line 110
	LDX	4049,#-0
;  111		PAADDR = 0x03;
.line 111
	LDX	4048,#3
;  112		PACTL = 0x00; //TTL Output
.line 112
	LDX	4049,#-0
;  113		PAADDR = 0x00;
.line 113
	LDX	4048,#-0
;  114	
;  115		PCCTL |= 0x0C;	//PC2-3 are input
.line 115
	ORX	4057,#12
;  116		_slowBlink = BLINKOFF;
.line 116
	CLR	__slowBlink
;  117		_fastBlink = BLINKOFF;
.line 117
	CLR	__fastBlink
;  118	
;  119		SetLampAll(0);
.line 119
	CLR	_0_SetLampAll
	CLR	_0_SetLampAll+1
	CALL	_SetLampAll
;  120		EI();				//Enable all interrupts
.line 120
	EI
;  121		PBOUT |= 0xF8; //set to zero
.line 121
	ORX	4055,#248
;  122	  
;  123	}
.line 123
	RET	
.endfunc "Initialize",123,"_Initialize"
	SEGMENT ROM_DATA


;**************************** _SetLampAll ***************************
;Name                         Addr/Register   Size   Type
;__lightControl                      STATIC     64   variable
;i                                      RR0      2   variable
;value                         _0_SetLampAll      2   parameter


; Aggregate Stack Size: 0 (words)


	.FRAME _n_SetLampAll,?_n_SetLampAll,RDATA
_0_SetLampAll:
	DS	2*1
	SEGMENT pdriver_TEXT
;  124	 
;  125	 
;  126	
;  127		
;  128	
;  129	void SetLampAll(int value){
_SetLampAll:
.define "_SetLampAll"
.value _SetLampAll
.class 2
.type 65
.endef
.begfunc "SetLampAll",129,"_SetLampAll"
.define "value"
.class 23
.value _0_SetLampAll
.alias "_0_SetLampAll"
.type 3
.endef
.define "i"
.class 4
.reg 17
.type 3
.endef
;  130		int i;
;  131		for(i=0;i<64;i++){
.line 131
	CLR	R0
	CLR	R1
	JR	_3_L_5
_3_L_3:
;  132			_lightControl[i]=value;
.line 132
	LD	R3,_0_SetLampAll+1
	LD	R2,#__lightControl
	ADD	R2,R1
	LD	@R2,R3
.line 131
	INCW	RR0
;  133			}
_3_L_5:
.line 133
.line 131
	CP	R1,#64
	CPC	R0,#-0
	JR	LT,_3_L_3
;  134		}
.line 134
	RET	
.endfunc "SetLampAll",134,"_SetLampAll"
	SEGMENT ROM_DATA


;**************************** _SetLamp ***************************
;Name                         Addr/Register   Size   Type
;__lightControl                      STATIC     64   variable
;data                            _1_SetLamp      1   parameter
;lmp                             _0_SetLamp      2   parameter


; Aggregate Stack Size: 0 (words)


	.FRAME _n_SetLamp,?_n_SetLamp,RDATA
_0_SetLamp:
	DS	2*1
_1_SetLamp:
	DS	1
	SEGMENT pdriver_TEXT
;  135		
;  136	void SetLamp(int lmp, unsigned char data){
_SetLamp:
.define "_SetLamp"
.value _SetLamp
.class 2
.type 65
.endef
.begfunc "SetLamp",136,"_SetLamp"
.define "lmp"
.class 23
.value _0_SetLamp
.alias "_0_SetLamp"
.type 3
.endef
.define "data"
.class 23
.value _1_SetLamp
.alias "_1_SetLamp"
.type 12
.endef
;  137		//00=off, 01=on, 10=slow blink, 11=fast blink
;  138		_lightControl[lmp]=data;
.line 138
	LD	R0,#__lightControl
	ADD	R0,_0_SetLamp+1
	LD	@R0,_1_SetLamp
;  139	}
.line 139
	RET	
.endfunc "SetLamp",139,"_SetLamp"
	SEGMENT ROM_DATA
;	Jump Table for Switch Statement at line 170
L__9:
	DW	3
	DW	1
	DW	_5_L_9
	DW	2
	DW	_5_L_10
	DW	3
	DW	_5_L_14
	DW	_5_L_19


;**************************** _LampLoop ***************************
;Name                         Addr/Register   Size   Type
;_DiagLEDControl                     IMPORT  -----   function
;__fastBlink                         STATIC      1   variable
;__slowBlink                         STATIC      1   variable
;_pause                              STATIC  -----   function
;__ldu_map                           STATIC     64   variable
;__lightControl                      STATIC     64   variable
;i                                      _0i      2   variable


; Aggregate Stack Size: 0 (words)


	.FRAME _n_LampLoop,?_n_LampLoop,RDATA
_0i:
	DS	2*1
	.FCALL _n_pause
	.FCALL _n_DiagLEDControl
	SEGMENT pdriver_TEXT
;  140	
;  141	
;  142	void LampLoop(void){
_LampLoop:
.define "_LampLoop"
.value _LampLoop
.class 2
.type 65
.endef
.begfunc "LampLoop",142,"_LampLoop"
.define "i"
.class 22
.value _0i
.alias "_0i"
.type 3
.endef
;  143		int i;
;  144		unsigned long int count;
;  145	
;  146		/*
;  147	porta bit:
;  148	0=lamp0
;  149	1=lamp1
;  150	2=lamp2
;  151	3=lamp3
;  152	4=str0
;  153	5=str1
;  154	6=str2
;  155	7=str3
;  156	
;  157	portB:
;  158	0=LED1
;  159	1=LED2
;  160	2=LED3
;  161	3=n/a
;  162	4=Lamp Enable
;  163	*/	
;  164	
;  165	
;  166		PBOUT &= 0xEF; //PB4 is lamp enable (active low)
.line 166
	ANDX	4055,#239
;  167		while(1){
_5_L_23:
.line 167
;  168			//just loop through each lamp value...
;  169			for(i=0;i<64;i++){
.line 169
	CLR	_0i
	CLR	_0i+1
	JR	_5_L_20
_5_L_18:
;  170				switch(_lightControl[i]){
.line 170
	LD	R0,#__lightControl
	ADD	R0,_0i+1
	LD	R1,@R0
	CLR	R0
	LD	R2,#high(L__9)
	LD	R3,#low(L__9)
	CALL	__b_ucase
	JP	@RR0
;  171					case 1: //on
_5_L_9:
.line 171
;  172						PAOUT = _ldu_map[i];
.line 172
	LD	R0,#high(__ldu_map)
	LD	R1,#low(__ldu_map)
	ADD	R1,_0i+1
	ADC	R0,_0i
	LDC	R2,@RR0
	LDX	4051,R2
;  173						pause();
.line 173
	CALL	_pause
;  174						break;
.line 174
	JR	_5_L_19
;  175					case 2: //slow blink
_5_L_10:
.line 175
;  176						if(_slowBlink==0x01){
.line 176
	CP	__slowBlink,#1
	JR	NE,_5_L_12
;  177							PAOUT = _ldu_map[i];
.line 177
	LD	R0,#high(__ldu_map)
	LD	R1,#low(__ldu_map)
	ADD	R1,_0i+1
	ADC	R0,_0i
	LDC	R2,@RR0
	LDX	4051,R2
;  178							pause();
.line 178
	CALL	_pause
;  179						}
;  180						else{
.line 180
	JR	_5_L_19
_5_L_12:
;  181							PAOUT = 0x00;
.line 181
	LDX	4051,#-0
;  182						}
;  183						break;
.line 183
	JR	_5_L_19
;  184					case 3: //fast blink
_5_L_14:
.line 184
;  185						if(_fastBlink==0x01){
.line 185
	CP	__fastBlink,#1
	JR	NE,_5_L_16
;  186							PAOUT = _ldu_map[i];
.line 186
	LD	R0,#high(__ldu_map)
	LD	R1,#low(__ldu_map)
	ADD	R1,_0i+1
	ADC	R0,_0i
	LDC	R2,@RR0
	LDX	4051,R2
;  187							pause();
.line 187
	CALL	_pause
;  188						}
;  189						else{
.line 189
	JR	_5_L_19
_5_L_16:
;  190							PAOUT = 0x00;
.line 190
	LDX	4051,#-0
;  191						}
;  192						break;
;  193				}
;  194			}
_5_L_19:
.line 194
.line 169
	ADD	_0i+1,#1
	ADC	_0i,#0
_5_L_20:
.line 194
.line 169
	CP	_0i+1,#64
	CPC	_0i,#-0
	JR	LT,_5_L_18
;  195			DiagLEDControl(_lightControl[22]); //calling every end of loop using lamp 22
.line 195
	LD	_0_DiagLEDControl,__lightControl+22
	CALL	_DiagLEDControl
.line 167
	JR	_5_L_23
;  196	
;  197		}	
;  198	}
.line 198
	RET	
.endfunc "LampLoop",198,"_LampLoop"
	SEGMENT ROM_DATA
;	Jump Table for Switch Statement at line 206
L__16:
	DW	3
	DW	1
	DW	_6_L_26
	DW	2
	DW	_6_L_27
	DW	3
	DW	_6_L_31
	DW	_6_L_35


;**************************** _DiagLEDControl ***************************
;Name                         Addr/Register   Size   Type
;__fastBlink                         STATIC      1   variable
;__slowBlink                         STATIC      1   variable
;_lastDataReceived                   STATIC      1   variable
;command                       _0_DiagLEDControl      1   parameter


; Aggregate Stack Size: 0 (words)


	.FRAME _n_DiagLEDControl,?_n_DiagLEDControl,RDATA
_0_DiagLEDControl:
	DS	1
	SEGMENT pdriver_TEXT
;  199	
;  200	
;  201	void DiagLEDControl(unsigned char command){
_DiagLEDControl:
.define "_DiagLEDControl"
.value _DiagLEDControl
.class 2
.type 65
.endef
.begfunc "DiagLEDControl",201,"_DiagLEDControl"
.define "command"
.class 23
.value _0_DiagLEDControl
.alias "_0_DiagLEDControl"
.type 12
.endef
;  202		if(lastDataReceived!=0x00){
.line 202
	CP	_lastDataReceived,#0
	JR	Z,_6_L_36
;  203			lastDataReceived = 0x00;
.line 203
	CLR	_lastDataReceived
;  204		}
_6_L_36:
.line 204
;  205		
;  206		switch(command){
.line 206
	LD	R1,_0_DiagLEDControl
	CLR	R0
	LD	R2,#high(L__16)
	LD	R3,#low(L__16)
	CALL	__b_ucase
	JP	@RR0
;  207			case 1:
_6_L_26:
.line 207
;  208				PBOUT &= 0xFD; //on  
.line 208
	ANDX	4055,#253
;  209				break;
.line 209
	JR	_6_L_37
;  210			case 2:
_6_L_27:
.line 210
;  211				if(_slowBlink==0x01){
.line 211
	CP	__slowBlink,#1
	JR	NE,_6_L_29
;  212					PBOUT &= 0xFD;
.line 212
	ANDX	4055,#253
;  213					}
;  214					else{
.line 214
	JR	_6_L_37
_6_L_29:
;  215						PBOUT |= ~0xFD;
.line 215
	ORX	4055,#2
;  216						}
;  217				break;
.line 217
	JR	_6_L_37
;  218			case 3:
_6_L_31:
.line 218
;  219				if(_fastBlink==0x01){
.line 219
	CP	__fastBlink,#1
	JR	NE,_6_L_33
;  220					PBOUT &= 0xFD;
.line 220
	ANDX	4055,#253
;  221					}
;  222					else{
.line 222
	JR	_6_L_37
_6_L_33:
;  223						PBOUT |= ~0xFD;
.line 223
	ORX	4055,#2
;  224						}
;  225				break;
.line 225
	JR	_6_L_37
;  226			default:
_6_L_35:
.line 226
;  227				PBOUT |= ~0xFD; //off
.line 227
	ORX	4055,#2
;  228			}
;  229	}
_6_L_37:
.line 229
	RET	
.endfunc "DiagLEDControl",229,"_DiagLEDControl"
	SEGMENT ROM_DATA


;**************************** _RawUpSwitch ***************************
;Name                         Addr/Register   Size   Type
;temp                                    R0      1   variable


; Aggregate Stack Size: 0 (words)


	.FRAME _n_RawUpSwitch,?_n_RawUpSwitch,RDATA
	SEGMENT pdriver_TEXT
;  230	
;  231	
;  232	/*
;  233				switch(_diagMode){
;  234					case 1:
;  235						PBOUT &= 0xED; //on  (JAF changed to E from F so that PB4 is off(active low)
;  236						break;
;  237					case 2:
;  238						if(_slowBlink==0x01){
;  239							PBOUT &= 0xED;
;  240							}
;  241							else{
;  242								PBOUT |= ~0xED;
;  243								}
;  244						break;
;  245					case 3:
;  246						if(_fastBlink==0x01){
;  247							PBOUT &= 0xED;
;  248							}
;  249							else{
;  250								PBOUT |= ~0xED;
;  251								}
;  252						break;
;  253					default:
;  254						PBOUT |= ~0xED; //off
;  255					}
;  256	*/
;  257	
;  258	
;  259		/*
;  260		bool_t DebounceSwitch2()
;  261	{
;  262	    static uint16_t State = 0; // Current debounce status
;  263	    State=(State<<1) | !RawKeyPressed() | 0xe000;
;  264	    if(State==0xf000)return TRUE;
;  265	    return FALSE; 
;  266	}
;  267	*/
;  268	BOOL RawUpSwitch(){
_RawUpSwitch:
.define "_RawUpSwitch"
.value _RawUpSwitch
.class 2
.type 76
.endef
.begfunc "RawUpSwitch",268,"_RawUpSwitch"
.define "temp"
.class 4
.reg 1
.type 2
.endef
;  269		char temp;
;  270		temp = PCIN;
.line 270
;  271		return ((temp & 0x08) == 0x00);
.line 271
	TMX	4058,#8
	JR	NE,L__22
	LD	R1,#1
	JR	L__23
L__22:
	CLR	R1
L__23:
	LD	R0,R1
;  272	}
.line 272
	RET	
.endfunc "RawUpSwitch",272,"_RawUpSwitch"
	SEGMENT ROM_DATA


;**************************** _DebounceUpSwitch ***************************
;Name                         Addr/Register   Size   Type
;_1upState                           STATIC      2   variable
;temp42                                  R0      2   variable


; Aggregate Stack Size: 0 (words)


	.FRAME _n_DebounceUpSwitch,?_n_DebounceUpSwitch,RDATA
	.FCALL _n_RawUpSwitch
	SEGMENT NEAR_DATA
_1upState:
	DW	0
	SEGMENT pdriver_TEXT
;  273	
;  274	BOOL DebounceUpSwitch(){
_DebounceUpSwitch:
.define "_DebounceUpSwitch"
.value _DebounceUpSwitch
.class 2
.type 76
.endef
.begfunc "DebounceUpSwitch",274,"_DebounceUpSwitch"
;  275		static UINT16 upState = 0; //current debounce status
.define "upState"
.alias "_1upState"
.class 133
.value _1upState
.type 13
.endef
;  276		upState=(upState<<1) | !RawUpSwitch() | 0xe000;
.line 276
	CALL	_RawUpSwitch
	OR	R0,R0
	JR	NE,_8_L_40
	CLR	R0
	LD	R1,#1
	JR	_8_L_41
_8_L_40:
	CLR	R0
	CLR	R1
_8_L_41:
	ADD	_1upState+1,_1upState+1
	ADC	_1upState,_1upState
	OR	_1upState+1,R1
	OR	_1upState,R0
	OR	_1upState,#224
;  277		if(upState==0xf000) return TRUE;
.line 277
	CP	_1upState+1,#0
	CPC	_1upState,#240
	JR	NE,_8_L_44
	LD	R0,#1
	JR	_8_L_45
_8_L_44:
;  278		return FALSE;
.line 278
	CLR	R0
;  279	}
_8_L_45:
.line 279
	RET	
.endfunc "DebounceUpSwitch",279,"_DebounceUpSwitch"
	SEGMENT ROM_DATA
;	Jump Table for Switch Statement at line 291
L__32:
	DW	3
	DW	1
	DW	_9_L_49
	DW	2
	DW	_9_L_50
	DW	3
	DW	_9_L_51
	DW	_9_L_52


;**************************** _lampISR ***************************
;Name                         Addr/Register   Size   Type
;_SetLampAll                         IMPORT  -----   function
;__diagMode                          STATIC      1   variable


; Aggregate Stack Size: 0 (words)


	.FRAME _n_lampISR,?_n_lampISR,RDATA
	.FCALL _n_DebounceUpSwitch
	.FCALL _n_SetLampAll
	SEGMENT pdriver_TEXT
;  280	
;  281	void lampISR()
;  282	{
_lampISR:
.define "_lampISR"
.value _lampISR
.class 2
.type 65
.endef
.begfunc "lampISR",282,"_lampISR"
;  283		
;  284		if(DebounceUpSwitch()){
.line 284
	CALL	_DebounceUpSwitch
	OR	R0,R0
	JR	Z,_9_L_55
;  285			//pressed, so increment where we are in the diagnosis
;  286			if(_diagMode>4)
.line 286
	CP	__diagMode,#4
	JR	ULE,_9_L_48
;  287				_diagMode = 0;
.line 287
	CLR	__diagMode
;  288			else
.line 288
	JR	_9_L_53
_9_L_48:
;  289				_diagMode++;
.line 289
	INC	__diagMode
_9_L_53:
;  290			
;  291			switch(_diagMode){
.line 291
	LD	R1,__diagMode
	CLR	R0
	LD	R2,#high(L__32)
	LD	R3,#low(L__32)
	CALL	__b_ucase
	JP	@RR0
;  292				case 1:
_9_L_49:
.line 292
;  293					SetLampAll(1);
.line 293
	CLR	_0_SetLampAll
	LD	_0_SetLampAll+1,#1
	CALL	_SetLampAll
;  294					break;
.line 294
	JR	_9_L_55
;  295				case 2:
_9_L_50:
.line 295
;  296					SetLampAll(2);
.line 296
	CLR	_0_SetLampAll
	LD	_0_SetLampAll+1,#2
	CALL	_SetLampAll
;  297					break;
.line 297
	JR	_9_L_55
;  298				case 3:
_9_L_51:
.line 298
;  299					SetLampAll(3);
.line 299
	CLR	_0_SetLampAll
	LD	_0_SetLampAll+1,#3
	CALL	_SetLampAll
;  300					break;
.line 300
	JR	_9_L_55
;  301				default:
_9_L_52:
.line 301
;  302					SetLampAll(0);
.line 302
	CLR	_0_SetLampAll
	CLR	_0_SetLampAll+1
	CALL	_SetLampAll
;  303				}
;  304		}
;  305	}
_9_L_55:
.line 305
	RET	
.endfunc "lampISR",305,"_lampISR"
	SEGMENT ROM_DATA
;	Jump Table for Switch Statement at line 315
L__36:
	DW	4
	DW	0
	DW	_10_L_57
	DW	1
	DW	_10_L_58
	DW	2
	DW	_10_L_59
	DW	3
	DW	_10_L_60
	DW	_10_L_63


;**************************** _blinkISR ***************************
;Name                         Addr/Register   Size   Type
;__fastBlink                         STATIC      1   variable
;__slowBlink                         STATIC      1   variable
;__timerControl                      STATIC      2   variable


; Aggregate Stack Size: 0 (words)


	.FRAME _n_blinkISR,?_n_blinkISR,RDATA
	SEGMENT pdriver_TEXT
;  306		
;  307		
;  308	
;  309	
;  310	void blinkISR(){
_blinkISR:
.define "_blinkISR"
.value _blinkISR
.class 2
.type 65
.endef
.begfunc "blinkISR",310,"_blinkISR"
;  311		if(_timerControl>3){
.line 311
	CP	__timerControl+1,#3
	CPC	__timerControl,#-0
	JR	LE,_10_L_61
;  312			_timerControl = 0;
.line 312
	CLR	__timerControl
	CLR	__timerControl+1
;  313		}
_10_L_61:
.line 313
;  314		
;  315		switch(_timerControl){
.line 315
	LD	R0,__timerControl
	LD	R1,__timerControl+1
	LD	R2,#high(L__36)
	LD	R3,#low(L__36)
	CALL	__b_ucase
	JP	@RR0
;  316			case 0:
_10_L_57:
.line 316
;  317				_slowBlink=0x00;
.line 317
	CLR	__slowBlink
;  318				_fastBlink =0x00;
.line 318
	CLR	__fastBlink
;  319				break;
.line 319
	JR	_10_L_63
;  320			case 1:
_10_L_58:
.line 320
;  321				_slowBlink = 0x00;
.line 321
	CLR	__slowBlink
;  322				_fastBlink=0x01;
.line 322
	LD	__fastBlink,#1
;  323				break;
.line 323
	JR	_10_L_63
;  324			case 2:
_10_L_59:
.line 324
;  325				_slowBlink = 0x01;
.line 325
	LD	__slowBlink,#1
;  326				_fastBlink = 0x00;
.line 326
	CLR	__fastBlink
;  327				break;
.line 327
	JR	_10_L_63
;  328			case 3:
_10_L_60:
.line 328
;  329				_slowBlink = 0x01;
.line 329
	LD	__slowBlink,#1
;  330				_fastBlink = 0x01;
.line 330
	LD	__fastBlink,#1
;  331				break;
;  332			}
_10_L_63:
.line 332
;  333			
;  334			_timerControl++;
.line 334
	ADD	__timerControl+1,#1
	ADC	__timerControl,#0
;  335		}
.line 335
	RET	
.endfunc "blinkISR",335,"_blinkISR"
	SEGMENT ROM_DATA


;**************************** _processMessage ***************************
;Name                         Addr/Register   Size   Type
;_lastDataReceived                   STATIC      1   variable
;__lightControl                      STATIC     64   variable
;__dataIn                            STATIC      4   variable
;lampValue                              RR2      2   variable
;lampAddress                            RR0      2   variable
;dataIn                        _1_processMessage      4   parameter
;data                                    R4      1   parameter


; Aggregate Stack Size: 0 (words)


	.FRAME _n_processMessage,?_n_processMessage,RDATA
_0_processMessage:
	DS	1
_1_processMessage:
	DS	4*1
	SEGMENT pdriver_TEXT
;  336		
;  337		
;  338	//Processes the I2C message
;  339	void processMessage(unsigned char data, long dataIn){
_processMessage:
.define "_processMessage"
.value _processMessage
.class 2
.type 65
.endef
.begfunc "processMessage",339,"_processMessage"
.line 339
	LD	R4,_0_processMessage
.define "data"
.class 17
.reg 5
.type 12
.endef
.define "dataIn"
.class 23
.value _1_processMessage
.alias "_1_processMessage"
.type 5
.endef
.define "lampAddress"
.class 4
.reg 17
.type 3
.endef
.define "lampValue"
.class 4
.reg 18
.type 3
.endef
;  340		//two 6 bits are the lamp
;  341		int lampAddress = 0x3f & (data>>2);
.line 341
	LD	R1,R4
	SRL	R1
	SRL	R1
	AND	R1,#63
	CLR	R0
;  342		int lampValue = 0x03 & data;
.line 342
	LD	R3,R4
	AND	R3,#3
	CLR	R2
;  343			
;  344		_dataIn = dataIn;
.line 344
	LD	__dataIn,_1_processMessage
	LD	__dataIn+1,_1_processMessage+1
	LD	__dataIn+2,_1_processMessage+2
	LD	__dataIn+3,_1_processMessage+3
;  345		_lightControl[lampAddress]=lampValue;
.line 345
	LD	R5,#__lightControl
	ADD	R5,R1
	LD	@R5,R3
;  346		lastDataReceived = data;
.line 346
	LD	_lastDataReceived,R4
;  347		return;
;  348	}
.line 348
	RET	
.endfunc "processMessage",348,"_processMessage"
	SEGMENT ROM_DATA


;**************************** _pause ***************************
;Name                         Addr/Register   Size   Type
;count                              _2count      4   variable


; Aggregate Stack Size: 0 (words)


	.FRAME _n_pause,?_n_pause,RDATA
_2count:
	DS	4*1
	SEGMENT pdriver_TEXT
;  349	
;  350	static void pause( void )
;  351	{
_pause:
.define "_pause"
.value _pause
.class 3
.type 65
.endef
.begfunc "pause",351,"_pause"
.define "count"
.class 22
.value _2count
.alias "_2count"
.type 15
.endef
;  352	   unsigned long int count = 20;//60;//214 //53581;
.line 352
	CLR	_2count
	CLR	_2count+1
	CLR	_2count+2
	LD	_2count+3,#20
;  353	   
;  354	   while ( count > 0 )
.line 354
	JR	_12_L_66
_12_L_67:
;  355	      count -= 1;
.line 355
	SUB	_2count+3,#1
	SBC	_2count+2,#0
	SBC	_2count+1,#0
	SBC	_2count,#0
_12_L_66:
.line 354
	CP	_2count+3,#0
	CPC	_2count+2,#-0
	CPC	_2count+1,#-0
	CPC	_2count,#-0
	JR	UGT,_12_L_67
;  356	      
;  357	   return;
;  358	}
.line 358
	RET	
.endfunc "pause",358,"_pause"
	XREF _InitializeI2C:ROM
	XREF __b_ucase:ROM
	XDEF _1_processMessage
	XDEF _0_processMessage
	XDEF _processMessage
	XDEF _blinkISR
	XDEF _lampISR
	XDEF _DebounceUpSwitch
	XDEF _RawUpSwitch
	XDEF _0_DiagLEDControl
	XDEF _DiagLEDControl
	XDEF _LampLoop
	XDEF _1_SetLamp
	XDEF _0_SetLamp
	XDEF _SetLamp
	XDEF _0_SetLampAll
	XDEF _SetLampAll
	XDEF _Initialize
	XDEF _main
	XDEF _lastDataReceived
	XDEF _ledIsOn
	XDEF _BLINKOFF
	XDEF _BLINKON
	XDEF __lampCounter
	XDEF __timerControl
	XDEF __diagMode
	XDEF __lmp
	XDEF __strobe
	XDEF __fastBlink
	XDEF __slowBlink
	XDEF __lightControl
	XDEF __dataIn
	XDEF __ldu_map
	END
